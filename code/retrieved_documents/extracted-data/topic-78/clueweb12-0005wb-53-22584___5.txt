coding with linked list coding with linked list, printing the list, using recursion to print list,  de-allocating the memory used for the linked list, watch the pointers: prepend  function, passing pointers by reference, array vs linked list, insert in sorted  (order) linked list, insert in sorted order: code, recursive insert favorites lecture 14 - algorithm analysis algorithm analysis, evaluating the performance, analysis of codes:  statement counts, another example (statement count contd.),
, c++ console i/o favorites lecture 4 - c++ console i/o c++ console i/o,
comparing algorithm, big-o notation, big-o to predict the time of execution, best/worst/average case, analysis of recursive algorithms, another example : towers of hanoi, a tabulation for different algorithms, growth patterns, application of algorithm analysis to sorting, selection sort, selection sort code selection sort, live demo: working/execution of the code, selection sort analysis, insertion sort algorithm, live demo: working/execution of insertion sort, insertion sort analysis, insertion vs selection, quadratic growth of the algorithm, merge sort, merge sort: working/execution demo, merge sort code explanation, merge sort analysis, quadratic vs linear arithmetic, sort 'race', quick sort idea partitioning for quicksort, quicksort code working/execution, quicksort code, live demo: running quicksort vs merge sort, bad split example, worst case split, what input has worst case for quick sort, live demo: running quicksort vs merge sort, different input scenarios, strategy to avoid worst case split, execution time tabulation, towards generic functions: swap, function template, example live code, template instantiation and its errors, sort template, client use of sort template sort template with callback, supplying the callback function, one last convenience: default callback function, why object oriented programming, class division, class interface in ".h"
note: this course is being offered by stanford this summer as an online course for credit.
object-oriented programming, fundamental data structures (such as stacks, queues, sets) and data-directed design.
about the introduction to computer science series at stanford, the philosophy, why take cs106b?, logistics of the course, introducing c++ similarity between c++ & java: - syntax - variable types - operators - control structures, looking at an example c++ code: - comment, #include statements, global declarations (constant), declaring a function prototype, the main() function, decomposed function definition, example live coding: to calculate the average, for loop -> a while : another purpose of the same code, c++ user defined data types: -enums -records, c++ parameters passing: -pass by value - pass by reference c++ libraries - standard libraries, cs106 libraries, cs106 random.h library, c++ string type, operations on string type, string class' member functions, c++ string vs java string, live example code : working on strings, cs106 strutils.h library, c++ string vs c string, concatenation pitfall (c++ vs c string cont.), c++ console i/o c++ console i/o, c++ file i/o, stream operations, live example coding : working with files, live coding continuation: function to operate on the opened file stream, passing the file stream by reference, error function, class libraries oo features, why oo is so successful, cs106 class library, cs106:
iterator operation through the map, iterating over the map, set class, set client interface, live
coding  example: use of map, more information on maps, what s missing?
file, storage for objects, accessing members of a class, class implementation, implementing member functions, maintaining object consistency, constructors of a class, destructors of a class, basic thoughts on object design, internal vs external representation: idea of encapsulation, better representation, adts (abstract data types)
comparing  algorithm, big-o notation, big-o to predict the time of execution,  best/worst/average case, analysis of recursive algorithms, another example :  towers of hanoi, a tabulation for different algorithms, growth patterns,  application of algorithm analysis to sorting, selection sort, selection sort  code favorites lecture 15 - selection sort selection sort, live demo: working/execution of the code, selection sort  analysis, insertion sort algorithm, live demo: working/execution of insertion  sort, insertion sort analysis, insertion vs selection, quadratic growth of the  algorithm, merge sort, merge sort: working/execution demo, merge sort code  explanation, merge sort analysis, quadratic vs linear arithmetic, sort 'race',  quick sort idea favorites lecture 16 - partitioning for quicksort partitioning for quicksort, quicksort code working/execution, quicksort  code, live demo: running quicksort vs merge sort, bad split example, worst case  split, what input has worst case for quick sort, live demo: running quicksort  vs merge sort, different input scenarios, strategy to avoid worst case split,  execution time tabulation, towards generic functions: swap, function template,  example live code, template instantiation and its errors, sort template, client  use of sort template favorites lecture 17 - sort template with callback sort template with callback, supplying the callback function, one last
recursively, functional recursion, example of  recursion:
software engineering principles of data abstraction and modularity.
prerequisites: solid performance inprogramming methodology and readiness to move on to advanced programming topics.
so far, noticing patterns/repetitions in the words, letter  trie, lexicon as trie, dynamic array of children, flatten tree into array,  exploiting prefixes and suffixes, dawg: directed acyclic word graph, lexicon as  dawg, the final result, cool facts about the dawg favorites lecture 26 - final showdown final showdown, thinking about design, runtime performance, memory used,  code complexity, making tradeoffs, array vs vector, stack/queue vs vector, set  vs sorted vector, pointer-based vs. contiguous memory, cs106b mvps, pointers,  to remember years from now, after cs106b, considering.cs favorites lecture 27 - about the c++ language, quick history of c++, c++ philosophy guest lecturer: keith schwarz, about the c++ language, quick history of  c++, c++ philosophy, c++
it can be taken individually, or as part of a master’s degree or graduate certificate earned online through the stanford center for professional development.
recursion and recursive data structures (linked lists, trees, graphs).
programming abstractions assumes that you already have familiarity with  good programming style and software engineering issues (at the level of  programming methodology), and that you can use this understanding as a  foundation on which to tackle new topics in programming and data abstraction.
lectures favorites lecture 1 - about the introduction to computer science series at stanford about the introduction to computer science series at stanford, the  philosophy, why take cs106b?, logistics of the course, introducing c++ favorites lecture 2 - similarity between c++ & java: - syntax - variable types -  operators - control structures similarity between c++ & java: - syntax - variable types - operators -  control structures, looking at an example c++ code: - comment, #include  statements, global declarations (constant), declaring a function prototype, the  main() function, decomposed function definition, example live coding: to  calculate the average, for loop -> a while : another purpose of the same  code, c++ user defined data types: -enums -records, c++ parameters passing:  -pass by value - pass by reference favorites lecture 3 - c++ libraries - standard libraries c++ libraries - standard libraries, cs106 libraries, cs106 random.h  library, c++ string type, operations on string type, string class'
recursion and recursive data structures (linked lists,  trees, graphs).
live coding example:  creating the vector class, private data members, growing dynamically:
specific plot functions seeing functions as data: specific plot functions, generic plot function,
member  functions, c++ string vs java string, live example code : working on strings,  cs106 strutils.h library, c++ string vs c string, concatenation pitfall (c++ vs  c string cont.)
programming abstractions assumes that you already have familiarity with good programming style and software engineering issues (at the level of programming methodology), and that you can use this understanding as a foundation on which to tackle new topics in programming and data abstraction.
back to the set, live coding example: use of set with user defined data types,  client callback function, review of the classes seen,5 using nested adts
resources from our friends: open culture | grockit
topics: abstraction and its relation to programming.
c++ file i/o, stream operations, live example coding :  working with files, live coding continuation: function to operate on the opened  file stream, passing the file stream by reference, error function, class  libraries oo features, why oo is so successful, cs106 class library, cs106:  scanner library, scanner client interface, client use of scanner, container  classes, template containers, vector interface favorites lecture 5 - client use of templates client use of templates, vector class, vector client interface, client use  of vector, type-safety in templates, grid class, grid client interface, client  use of grid, stack class, stack client interface, queue class, queue client  interface, client use of queue, nested templates, learning a new api, cs106b  library documentation favorites lecture 6 - more containers more containers, map class, uses of map, map client interface, live
coding example : use of set, set higher-level operations, why set is different seeing functions as data:
object-oriented  programming, fundamental data structures (such as stacks, queues, sets) and  data-directed design.
computer science ii: programming abstractions julie zelenski tweet course description note: this course is being offered by stanford this summer as an online  course for credit.
favorites lecture 23 - pathfinder demo pathfinder demo, graphs: examples, graphs: explanation, implementation  strategies, graph representation in c++, nodes and arcs in c++, graph  traversals, dfs - (depth first search), trace dfs, bfs - (breadth first  search), trace bfs, graph search algorithms, weighted arcs favorites lecture 24 - compare map implementations compare map implementations, hashtable idea, hash functions, hash  collisions, live demo:
introduction to time and space complexity analysis.
a comparable introductory programming course (including high school ap courses) is often a reasonable substitute for our programming methodology.
specific plot functions, generic plot function, back to the set, live coding example: use of set with user defined data types, client callback function, review of the classes seen,5 using nested adts (abstract data types), live coding example, recursion, recursive decomposition stumbled upon: 'i'terator, common mistakes stumbled upon: concatenating strings, solving problems recursively, functional recursion, example of recursion: calculating raise to power, demo of "raise to the power example" through live coding, mechanics of what s going to happen in recursion, more efficient recursion, being wary of too many base cases, recursion & efficiency, example: palindromes, example: binary search, binary search code walk through, choosing a subset; choose code thinking recursively, procedural vs functional recursion, fractal code, live demo: fractal example, another recursive graphic: mondrian art, random pseudo-mondrian and the code, hanois towers : classic recursion example, tower code, live demo, permutations, permute code, tree of recursive calls refresh: permute code, tree of recursive calls, live demo: testing with different cases, eliminating duplicates, subsets, subset strategy, subset code, tree of recursivecalls: subset, exhaustive recursion, recursive backtracking, turning recursive permute to backtracking, permute -> anagram finder code, decision problems: 8 queens, extension to n queens backtracking pseudocode, sudoku solver, sudoku code, cryptarithmetic, dumb solver, smarter solver, looking for patterns, introduction to pointers, single pointer operations pointer movie, pointer operations: code & pointer memory diagrams, pointer basics, pointer and dynamic arrays, use of pointers, recursive data, a recursive structure, live demo: working with linked list, building the list coding with linked list, printing the list, using recursion to print list, de-allocating the memory used for the linked list, watch the pointers: prepend function, passing pointers by reference, array vs linked list, insert in sorted (order) linked list, insert in sorted order: code, recursive insert algorithm analysis, evaluating the performance, analysis of codes: statement counts, another example (statement count contd.),
pathfinder demo, graphs: examples, graphs: explanation, implementation strategies, graph representation in c++, nodes and arcs in c++, graph traversals, dfs - (depth first search), trace dfs, bfs - (breadth first search), trace bfs, graph search algorithms, weighted arcs compare map implementations, hashtable idea, hash functions, hash collisions, live demo: hashing, live coding: hashing, hashing idea : example in real world, hash table performance, compare map implementations, hashing generic types, implementing set lexicon case study, lexicon as sorted vector, lexicon as bst, lexicon as hash table, summary so far, noticing patterns/repetitions in the words, letter trie, lexicon as trie, dynamic array of children, flatten tree into array, exploiting prefixes and suffixes, dawg: directed acyclic word graph, lexicon as dawg, the final result, cool facts about the dawg final showdown, thinking about design, runtime performance, memory used, code complexity, making tradeoffs, array vs vector, stack/queue vs vector, set vs sorted vector, pointer-based vs. contiguous memory, cs106b mvps, pointers, to remember years from now, after cs106b, considering.cs guest lecturer: keith schwarz, about the c++ language, quick history of c++, c++ philosophy, c++ without genlib.h, a working genlib.h replacement, other cs106 headers, strutils.h, simpio.h, random.h, graphics.h/extrgraph.h, what about adts?, standard template library, stl algorithms, language features, operator overloading, what next? source: stanford engineering everywhere license: about us | contact | privacy policy | terms of use | faq © 2012 academic earth.
scanner library, scanner client interface, client use of scanner, container classes, template containers, vector interface client use of templates, vector class, vector client interface, client use of vector, type-safety in templates, grid class, grid client interface, client use of grid, stack class, stack client interface, queue class, queue client interface, client use of queue, nested templates, learning a new api, cs106b library documentation more containers, map class, uses of map, map client interface, live coding example: use of map, more information on maps, what s missing?
uses the  programming language c++ covering its basic facilities.
convenience: default callback function, why object oriented programming, class  division, class interface in ".h"
hashing, live coding: hashing, hashing idea : example in  real world, hash table performance, compare map implementations, hashing  generic types, implementing set favorites lecture 25 - lexicon case study lexicon case study, lexicon as sorted vector, lexicon as bst, lexicon as  hash table, summary
(abstract data types),
live coding example, recursion, recursive decomposition favorites lecture 8 - common mistakes stumbled upon: 'i'terator stumbled upon: 'i'terator, common mistakes stumbled upon: concatenating  strings, solving problems
file, storage for objects,  accessing members of a class, class implementation, implementing member  functions, maintaining object consistency, constructors of a class, destructors  of a class, basic thoughts on object design, internal vs external  representation: idea of encapsulation, better representation, adts (abstract  data types) favorites lecture 18 - abstract data types abstract data types, wall of abstraction, why adts?,
abstract data types, wall of abstraction, why adts?, live coding example: creating the vector class, private data members, growing dynamically: making space at runtime, insert and remove functions, templatizing the class created, including the "template.cpp" - why?
prerequisites: solid performance inprogramming methodology and readiness to  move on to advanced programming topics.
if you've taken the computer  science ap exam and done well (scored 4 or 5) or earned a good grade in a  college course, programming abstractions may be an appropriate course for you  to start with, but often programming abstractions (accelerated) is a better  choice.
a comparable introductory programming  course (including high school ap courses) is often a reasonable substitute for  our programming methodology.
rules of template implementation, explanation of the working, not allow member wise copy, insertat function, consequences of contiguous memory being a disadvantage, stack class, the member function definitions, midterm post mortem live coding: recap of the vector-based implementation for stack, linked list implementation for stack, live coding:
this course is the natural successor to programming methodology and covers such advanced programming topics as recursion, algorithmic analysis, and data abstraction using the c++ programming language, which is similar to both c and java.
if you've taken the computer science ap exam and done well (scored 4 or 5) or earned a good grade in a college course, programming abstractions may be an appropriate course for you to start with, but often programming abstractions (accelerated) is a better choice.
linked list implementation for stack, analyzing push/pop functions, queue implementation, live coding: queue implementation, alternative implementation, text editor case study, buffered class interface and buffer layered on vector, live coding: text editor, evaluate vector buffer, buffer layered on stack, live demo, compare implementations, buffer as linked list buffer: vector vs stack, buffer as linked list, cursor design, use of dummy cell, linked list insert/delete, linked list cursor movement, compare implementation, doubly linked list, compare implementation, space time trade off, implementing map, simple map implementation: vector, map as vector : performance implication, a different strategy map as vector, a different strategy: binary search tree, trees in general, binary search tree for numbers, operating on trees, tree traversals at work, implementing map as tree, map - getvalue(), important syntactical advice, adding to a bst, trace treeenter(), passing nodes by reference, evaluate map as a tree, impact of the height of the tree, degenerate trees, what to do about unbalanced trees?
it can be taken individually, or as part of a master’s  degree or graduate certificate earned online through the stanford center for  professional development.
iterator  operation through the map, iterating over the map, set class, set client  interface, live coding example : use of set, set higher-level operations, why  set is different favorites lecture 7 - seeing functions as data:
software  engineering principles of data abstraction and modularity.
this course is the natural successor to  programming methodology and covers such advanced programming topics as  recursion, algorithmic analysis, and data abstraction using the c++ programming  language, which is similar to both c and java.
calculating raise to power, demo of "raise to the power  example" through live coding, mechanics of what s going to happen in  recursion, more efficient recursion, being wary of too many base cases,  recursion & efficiency, example: palindromes, example: binary search,  binary search code walk through, choosing a subset; choose code favorites lecture 9 - thinking recursively thinking recursively, procedural vs functional recursion, fractal code,  live demo: fractal example, another recursive graphic: mondrian art, random  pseudo-mondrian and the code, hanois towers : classic recursion example, tower  code, live demo, permutations, permute code, tree of recursive calls favorites lecture 10 - refresh: permute code refresh: permute code, tree of recursive calls, live demo: testing with  different cases, eliminating duplicates, subsets, subset strategy, subset code,  tree of recursivecalls: subset, exhaustive recursion, recursive backtracking,  turning recursive permute to backtracking, permute -> anagram finder code,  decision problems: 8 queens, extension to n queens favorites lecture 11 - backtracking pseudocode backtracking pseudocode, sudoku solver, sudoku code, cryptarithmetic, dumb  solver, smarter solver, looking for patterns, introduction to pointers, single  pointer operations favorites lecture 12 - pointer movie pointer movie, pointer operations: code & pointer memory diagrams,  pointer basics, pointer and dynamic arrays, use of pointers, recursive data, a  recursive structure, live demo: working with linked list, building the list favorites lecture 13 -
without genlib.h, a working genlib.h replacement,  other cs106 headers, strutils.h, simpio.h, random.h, graphics.h/extrgraph.h,  what about adts?, standard template library, stl algorithms, language features,  operator overloading, what next?
making  space at runtime, insert and remove functions, templatizing the class created,  including the "template.cpp" - why? favorites lecture 19 - rules of template implementation rules of template implementation, explanation of the working, not allow  member wise copy, insertat function, consequences of contiguous memory being a  disadvantage, stack class, the member function definitions, midterm post mortem favorites lecture 20 - live coding: recap of the vector-based implementation for  stack live coding: recap of the vector-based implementation for stack, linked  list implementation for stack, live coding: linked list implementation for  stack, analyzing push/pop functions, queue implementation, live coding: queue  implementation, alternative implementation, text editor case study, buffered  class interface and buffer layered on vector, live coding: text editor,  evaluate vector buffer, buffer layered on stack, live demo, compare  implementations, buffer as linked list favorites lecture 21 - buffer: vector vs stack buffer: vector vs stack, buffer as linked list, cursor design, use of dummy  cell, linked list insert/delete, linked list cursor movement, compare  implementation, doubly linked list, compare implementation, space time trade  off, implementing map, simple map implementation: vector, map as vector :  performance implication, a different strategy favorites lecture 22 - map as vector map as vector, a different strategy: binary search tree, trees in general,  binary search tree for numbers, operating on trees, tree traversals at work,  implementing map as tree, map - getvalue(), important syntactical advice,  adding to a bst, trace treeenter(), passing nodes by reference, evaluate map as  a tree, impact of the height of the tree, degenerate trees, what to do about  unbalanced trees?
uses the programming language c++ covering its basic facilities.